<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>领域驱动设计 on sun17 wiki</title><link>https://yino.github.io/wiki/DDD/</link><description>Recent content in 领域驱动设计 on sun17 wiki</description><generator>Hugo -- gohugo.io</generator><language>en</language><atom:link href="https://yino.github.io/wiki/DDD/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://yino.github.io/wiki/DDD/domain/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://yino.github.io/wiki/DDD/domain/</guid><description>domain 实体 （model） a. 唯一要素（必须有唯一标识）
b. 实体只能通过唯一标识来判断两者是否想同
值对象 实体的额外信息
a. 值对象 只能通过值判断两者是否相同 用来描述用户的额外信息
聚合 a. 包括一组领域对象（包括实体和值对象），完整描述一个领域业务，其中必然有个根实体。这个叫做聚合根。
i. 例： 比如用户登录这个聚合，用户实体就是聚合根（包含了各个值对象）ii. 例： 用户日志功能。其中用户日志包含了，用户登录日志，用户购买日志，用户充值日志。 这三个聚合。用户实体都是他们的聚合根。b. 聚合和聚合之间可以相互引用但是 是根之间相互引用
仓储 （repository）：为每一个聚合根实体创建一个仓储接口，并且不和底层数据库交互。作用：更好的把我们的精力集中在领域逻辑上 ()
DTO 数据传输对象 http 响应字段</description></item><item><title/><link>https://yino.github.io/wiki/DDD/PO-DO-VO-DTO/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://yino.github.io/wiki/DDD/PO-DO-VO-DTO/</guid><description>VO（View Object）：视图对象，用于展示层，它的作用是把某个指定页面（或组件）的所有数据封装起来。 用户提交的数据 req
DTO（Data Transfer Object）：数据传输对象，这个概念来源于J2EE的设计模式，原来的目的是为了EJB的分布式应用提供粗粒度的数据实体，以减少分布式调用的次数，从而提高分布式调用的性能和降低网络负载，但在这里，我泛指用于展示层与服务层之间的数据传输对象。将VO转换为服务(DO)所需要的参数.
DO（Domain Object）：领域对象，就是从现实世界中抽象出来的有形或无形的业务实体。
PO（Persistent Object）：持久化对象，它跟持久层（通常是关系型数据库）的数据结构形成一一对应的映射关系，如果持久层是关系型数据库，那么，数据表中的每个字段（或若干个）就对应PO的一个（或若干个）属性。
VO与DTO的区别
大家可能会有个疑问（在笔者参与的项目中，很多程序员也有相同的疑惑）：既然DTO是展示层与服务层之间传递数据的对象，为什么还需要一个VO呢？对！对于绝大部分的应用场景来说，DTO和VO的属性值基本是一致的，而且他们通常都是POJO，因此没必要多此一举，但不要忘记这是实现层面的思维，对于设计层面来说，概念上还是应该存在VO和DTO，因为两者有着本质的区别，DTO代表服务层需要接收的数据和返回的数据，而VO代表展示层需要显示的数据。 用一个例子来说明可能会比较容易理解：例如服务层有一个getUser的方法返回一个系统用户，其中有一个属性是gender(性别)，对于服务层来说，它只从语义上定义：1-男性，2-女性，0-未指定，而对于展示层来说，它可能需要用“帅哥”代表男性，用“美女”代表女性，用“秘密”代表未指定。说到这里，可能你还会反驳，在服务层直接就返回“帅哥美女”不就行了吗？对于大部分应用来说，这不是问题，但设想一下，如果需求允许客户可以定制风格，而不同风格对于“性别”的表现方式不一样，又或者这个服务同时供多个客户端使用（不同门户），而不同的客户端对于表现层的要求有所不同，那么，问题就来了。再者，回到设计层面上分析，从职责单一原则来看，服务层只负责业务，与具体的表现形式无关，因此，它返回的DTO，不应该出现与表现形式的耦合。 理论归理论，这到底还是分析设计层面的思维，是否在实现层面必须这样做呢？一刀切的做法往往会得不偿失，下面我马上会分析应用中如何做出正确的选择。</description></item><item><title/><link>https://yino.github.io/wiki/DDD/%E5%AE%9E%E8%B7%B5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://yino.github.io/wiki/DDD/%E5%AE%9E%E8%B7%B5/</guid><description>项目地址 # 项目简介 # 此项目是打造一个nlp的开源平台，并提供相应的api；用户可根据自己的应用场景去选择相应的模型，同时用户可以根据自己的数据去训练，达到更高的效果。
现有以下几种场景：
1. QA（问答系统）根据用户输入的问题，去自己的训练库中咨询查找匹配的问题。 2. 文本纠错。 3. 闲聊对话，根据用户输入的文本，去系统文本库中匹配文本，达到一个与用户交互的模式。 欢迎大佬一起参与！
架构 # nlp-template VUE开发模板
nlp-controller golang开发上层业务
nlp-model py开发 模型
nlp-controller 项目架构 # 项目采用DDD(Domain Driven Design)架构，
nlp-controller ├── application ├── domain │ ├── aggregate │ │ └── qa_question_factory.go │ ├── entity │ │ │── qa_question.go │ │ └── user.go │ ├── event │ ├── po │ │ │── user.go │ │ │── user_ak.go │ │ └── qa_question.go │ ├── repository │ │ │── question.</description></item><item><title/><link>https://yino.github.io/wiki/DDD/%E6%AD%A5%E9%AA%A4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://yino.github.io/wiki/DDD/%E6%AD%A5%E9%AA%A4/</guid><description>步骤 1. 需求分析（统一语言：比如PPT、原型图 需统一！） 2. 领域分析 3. 领域边界划分 4. 领域建模 5. 核心业务逻辑 6. 技术细节 Domain StoryTelling Pictograms and VOcabulary 1. Actors - 角色参与者故事场景参与者 2. WorkObjects - 参与者与参与者传递的信息 3. Activities - 关系 Actors 与 WorkObjects 关系 4. Annotations - 解释 Domain Design 1. DDD a. Bounded Context - 界限上下文 b. Aggregate - 聚合根 c. Entities - 实体 i. 唯一标识 ii. 有状态 iii. 例如订单实体 d. Value Object - 值对象 i. 无实体 ii. 例如订单中的 address 改变并不会影响订单 e.</description></item><item><title/><link>https://yino.github.io/wiki/DDD/%E7%A4%BA%E4%BE%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://yino.github.io/wiki/DDD/%E7%A4%BA%E4%BE%8B/</guid><description>电商领域： 核心领域 销售
支撑子域 除去销售外的其他子域通用子域 比如：通知（短信等）界限上下文
目的：控制边界领域模型
先抽象领域
领域：反应业务上需要解决的问题
四层架构
interface 用户展示层
application 应用层 协调工作层
domain 领域层 业务规则
基础设施层 mysql中间件等
拆分 微服务设计原则
1. 要领域驱动设计，而不是数据驱动设计，也不是界面驱动设计2. 要边界清晰的微服务。而不是泥球3. 要职能清晰的分层，而不是什么都放一起4. 不能过度拆分</description></item><item><title/><link>https://yino.github.io/wiki/DDD/%E8%81%9A%E5%90%88/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://yino.github.io/wiki/DDD/%E8%81%9A%E5%90%88/</guid><description> 什么是聚合？ # Aggregate就是一组相关对象的的集合，我们把它作为数据修改和访问的单元。
聚合关系 （核心两点） # 若一个个体在整体没有创建之前就已经存在，则不是聚合。
若一个个体消亡了，与这个个体相关的，同时消亡则就是聚合。
例子 # 1. 如果一个客户消亡，则客户的联系方式、多张银行卡信息将不再有任何意义 2. 如果一张采购订单取消，则采购订单的商品明细则没有任何存在的意义。 3. 医生与处方：若医生不存在了，处方依旧有效，若处方不存在了，医生依旧有效；所以两者不是聚合； 4. 处方与药品明细（处方明细）： 若处方不存在则处方对应的药品明细就没有实际的作用。因此两者是聚合；</description></item></channel></rss>