<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Nginx on sun17 wiki</title><link>https://yino.github.io/wiki/Nginx/</link><description>Recent content in Nginx on sun17 wiki</description><generator>Hugo -- gohugo.io</generator><language>en</language><atom:link href="https://yino.github.io/wiki/Nginx/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://yino.github.io/wiki/Nginx/rewrite%E4%B8%8Eproxy_pass/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://yino.github.io/wiki/Nginx/rewrite%E4%B8%8Eproxy_pass/</guid><description> rewrite 与 proxy_pass # rewrite # 如果正则表达式（regex）匹配到了请求的URI（request URI），这个URI会被后面的replacement替换 rewrite的定向会根据他们在配置文件中出现的顺序依次执行 通过使用flag可以终止定向后进一步的处理 如果replacement以“http://”, “https://”, or “$scheme”开头，处理将会终止，请求结果会以重定向的形式返回给客户端（client） 如果replacement字符串里有新的request参数，那么之前的参数会附加到其后面，如果要避免这种情况，那就在replacement字符串后面加上“？”，eg： rewrite相当于是重定向到了目标网站，浏览器会跳转到目标网站 rewrite ^/users/(.*)$ /?user=$1? last;= proxy_pass # 不影响浏览器地址栏的url 设置被代理server的协议和地址，URI可选（可以有，也可以没有） 协议可以为http或https 地址可以为域名或者IP，端口可选；eg： proxy_pass http://localhost:8000/uri/; 如果proxy_pass的URL定向里包括URI，那么请求中匹配到location中URI的部分会被proxy_pass后面URL中的URI替换，eg： location /name/ { proxy_pass http://127.0.0.1/remote/; } 请求http://example.com/name/test.html 会被代理到http://127.0.0.1/remote/test.html 如果proxy_pass的URL定向里不包括URI，那么请求中的URI会保持原样传送给后端server，eg： location /name/ { proxy_pass http://127.0.0.1; } 请求http://example/name/test.html 会被代理到http://127.0.0.1/name/test.html</description></item><item><title/><link>https://yino.github.io/wiki/Nginx/%E7%A6%81%E7%BD%91%E6%AE%B5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://yino.github.io/wiki/Nginx/%E7%A6%81%E7%BD%91%E6%AE%B5/</guid><description>nginx 禁网段 # 单看nginx模块名ngx_http_access_module,很多人一定很陌生，但是deny和allow相比没一个人不知道的，实际上deny和allow指令属于ngx_http_access_module.我们想控制某个uri或者一个路径不让人访问，在nginx就得靠它了。
nginx的访问控制模块语法很简单，至少比apache好理解，apache的allow和deny的顺序让很多初学者抓头.好了具体看下这个插件的使用方法吧。
1、安装模块 这个模块内置在了nginx中，除非你安装中使用了&amp;ndash;without-http_access_module。如果你还没安装过nginx，那么请参考下ttlsa之前写的nginx安装.
2、指令 allow 语法: allow address | CIDR | unix: | all; 默认值: — 配置段: http, server, location, limit_except
允许某个ip或者一个ip段访问.如果指定unix:,那将允许socket的访问.注意：unix在1.5.1中新加入的功能，如果你的版本比这个低，请不要使用这个方法。
deny 语法: deny address | CIDR | unix: | all; 默认值: — 配置段: http, server, location, limit_except
禁止某个ip或者一个ip段访问.如果指定unix:,那将禁止socket的访问.注意：unix在1.5.1中新加入的功能，如果你的版本比这个低，请不要使用这个方法。
allow、deny实例 location / { deny 192.168.1.1; allow 192.168.1.0/24; allow 10.1.1.0/16; allow 2001:0db8::/32; deny all; } 从上到下的顺序，类似iptables。匹配到了便跳出。如上的例子先禁止了192.16.1.1，接下来允许了3个网段，其中包含了一个ipv6，最后未匹配的IP全部禁止访问. 在实际生产环境中，我们也会使用nginx 的geo模块配合使用，有兴趣的请参考ttlsa相关文章nginx geo使用方法.
nginx访问控制模块要数nginx里面最简单的指令，只要记住你想禁止谁访问就deny加上IP，想允许则加上allow ip，想禁止或者允许所有，那么allow all或者deny all即可.
但是具体的配置出现很多问题
简单一点举例说明：</description></item></channel></rss>