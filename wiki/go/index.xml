<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Golang on sun17 wiki</title><link>https://kangkang17.cn/wiki/go/</link><description>Recent content in Golang on sun17 wiki</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://kangkang17.cn/wiki/go/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://kangkang17.cn/wiki/go/go-laravel/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kangkang17.cn/wiki/go/go-laravel/</guid><description>Golang-Laravel # 模仿PHP-Laravel，开箱即用、go语言版的laravel，phper转Go开发1 可以立马上手~
package # gin gorm go-redis go laravel 支持功能 # 路由 中间件 路由中间件 控制器 模型 验证器（*默认是英文，将其翻译为中文） 目录结构 # 与laravel几乎一模一样
app 应用目录
|---- exception 返回http状态及异常接收
|----|---- baseException.go panic异常接收文件
|---- http web核心目录
|----|---- controller 控制器存放目录
|----|---- middleware 路由中间件存放目录
|---- models 模型存放目录
|---- service 业务编写目录
|---- validate 验证器目录
|---- helpers.go 常用函数文件
config
|----|----app.go 应用配置 如：ip、port等
|----|----databases.go 数据库配置
extend 自定义扩展包
|----|---- log 自定义日志package(与系统log相同，增加按小时分割日志)
routes 路由文件夹
|----|---- route.</description></item><item><title/><link>https://kangkang17.cn/wiki/go/Go%E5%B9%B6%E5%8F%91%E5%8E%9F%E7%90%86%E5%8F%8AGPM%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kangkang17.cn/wiki/go/Go%E5%B9%B6%E5%8F%91%E5%8E%9F%E7%90%86%E5%8F%8AGPM%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5/</guid><description>并发&amp;amp;并行 # Go应该是在内核级现成的基础上做了一层l逻辑上的虚拟线程（用户级线程）+ 线程调度系统 #  假如我们有一段CPU密集型任务 我们创建2000个goroutine 是否真的将性能提高2000倍，其实并不能； 我们只是进行2000并发（concurrenc） 而并没有真正做到并行（parallelism）。 并发是指我们的程序执行逻辑，传统单线程应用的程序逻辑是顺序执行的，在任何时刻，程序只能处理同一个逻辑，而并发是指，我们同时执行多个独立的程序逻辑，若干个程序逻辑在执行时可以是同时进行的（但不代表同时进行处理 其实还是一次处理一个）。实际上，不论我们并发多少个程序逻辑，若我们仅仅运行在一个单核单线程的CPU上，都不能让你的程序在性能上有所提升，因为最终所有任务都排队等待CPU资源（时间片）. 而并行才能让我们的程序真正的同时处理多个任务，但并行并不是编程语言能够带我们的特性，他需要硬件支持。上面说到单核CPU所有资源都要等待同一个CPU的资源，那么其实我们只要将CPU增多就能真正的让我们实现并行。我们可以使用多核CPU或用多台服务器组成服务集群，均可实现真正的并行，能够并行处理的任务数量也就是我们的CPU数量。
CPU密集&amp;amp;I/O密集 #  如果我们的程序是CPU密集型（计算型，深度学习等），使用并发编程，可能确实无法提升我们程序的性能，甚至有可能会下降，创建线程等也是会消耗资源的。 如果我们的程序是I/O密集型，当你在进行程序压测时CPU可能很低，但性能却到了瓶颈，原因时大部分时间都浪费在了等待I/O的过程中；如果我们在等待I/O的同时继续去执行其他的程序逻辑即可提高CPUl利用率，从而提高程序的性能，这就是并发编程的优点；例如Python因为GIL的存在实际上并不能实现真正的并行，但他的多线程依旧在IO密集型的程序中依旧有种很重要的意义；（遇到I/O操作 则切换线程；单线程+ 协程可能更优；减少了切换线程的开销）；
Goroutine（Golang Coroutine） #  使用多核CPU实现并行处理，使应用在多核cpu实现并行处理的方案主要是多进程与多线程两种方式，多进程模型相对简单，但是有着资源开销大及进程间通信成本高的问题。多线程模型相对复杂，会有死锁，线程安全，模型复杂等问题，但却因为资源开销及易于管理等优点适用于对于性能要求较高的应用。 Golang采用的是多线程模型，更详细的说他是一个两级线程模型，但它对系统线程（内核级线程）进行了封装，暴露了一个轻量级的协程goroutine（用户级线程）供用户使用，而用户级线程到内核级线程的调度由golang的runtime负责，调度逻辑对外透明。 goroutine的优势在于上下文切换在完全用户态进行，无需像线程一样频繁在用户态与内核态之间切换，节约了资源消耗。
G·P·M # G（Goroutine） ：我们所说的协程，为用户级的轻量级线程，每个Goroutine对象中的sched保存着其上下文信息
M（Machine） ：对内核级线程的封装，数量对应真实的CPU数（真正干活的对象）、系统的
P（Processor） ：即为G和M的调度对象，用来调度G和M之间的关联关系，其数量可通过GOMAXPROCS()来设置，默认为核心数 他代表了真正的并发度，即有多少个goroutine可以同时运行</description></item><item><title/><link>https://kangkang17.cn/wiki/go/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kangkang17.cn/wiki/go/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</guid><description>垃圾回收 # 概述 GC &amp;amp; RC 垃圾回收的由来 逃逸分析的由来 垃圾回收，怎么实现？ 什么样的是垃圾？ 怎么把垃圾找出来？ 内存屏障 概述 # 现代编程语言一般都有垃圾回收功能。这个能极大的减轻程序员的负担，并且减少大部分场景的问题。
GC &amp;amp; RC # RC: 引用计数管理内存的方式 1. 使用前，为了保护对象不被销毁，计数 +1 2. 使用完后，计数 -1，计数减到 0 之后，就可以安全销毁了 GC: 垃圾回收管理内存的方式
golang 的垃圾回收我们经常听到三色标记法，三色指的是白色，灰色，黑色，分别表示三种状态，至于三色标记法的理论此处不表，我们从简单的理解切入。
怎么把垃圾找出来？ # 方法：从根处扫描，把所有的根扫描完，每个根扫描到底。按照之前的三色标记来说，扫描完了的是黑色，正在扫描的是灰色的，没扫描的是白色的。根扫描完了，那么最后只会剩下两种颜色的，黑色，白色。白色就是没用的垃圾，这种清理掉就没事。
根：栈，是扫描的起点，还有一些全局变量也是根，是起点
所谓的垃圾只对于堆上来说。栈上内存是编译器管理的，堆上内存是业务分配，垃圾回收器回收 垃圾怎么回收？怎么有效安全的回收？ # 起初的是最简单的思路STW(stop the world)，暂停所有程序，等待垃圾回收完再运行程序。当然这种模式在生产中不合适后又优化为 扫描-标记-清除</description></item><item><title/><link>https://kangkang17.cn/wiki/go/%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E5%BA%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kangkang17.cn/wiki/go/%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E5%BA%93/</guid><description>Golang-common # 安装 # go get github.com/yino/common InArray # 判断对象是否在 array 中 返回 bool
ArraySearch # 判断对象是否在 array 中 返回 int, bool (false 则不存在)
MapSearch # 判断对象是否在 map 中 返回interface, bool (false 则不存在)</description></item><item><title/><link>https://kangkang17.cn/wiki/go/%E7%99%BE%E4%B8%87%E8%81%8A%E5%A4%A9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kangkang17.cn/wiki/go/%E7%99%BE%E4%B8%87%E8%81%8A%E5%A4%A9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/</guid><description>聊天系统架构 百万级 B/S # 场景：100w人同时在线
技术选型 # B/S架构下 通常有两种方案： 1. 客户端主动向服务器拉取数据 2. 服务器主动向客户端发送数据 以上两种情况在B/S架构下通常对应着：http轮询 和 websocket 在线用户达到一定量级情况下，客户端主动拉取数据就会达到一定的瓶颈：对单表、api压力过大； 因此在用户量级略高的情况下建议采用 websocket websocket单机架构 # websocket 单机架构 代码案例地址: gitee github
技术难点 # 内核瓶颈 推送量大：100W*10条/秒=1000W条/秒 内核瓶颈：linux内核发送TCP极限包频≈100w 锁瓶颈 需要维护一个100w人的流量在线集合，通常是一个字典结构 推送消息即遍历整个集合，顺序发送消息，耗时极长 推送期间，客户端一直在进行上下线，所以需要对 map上锁 cpu瓶颈 浏览器与服务器之间通常采用json格式通讯 json编码非常消耗cpu 每秒100w次json encode 解决方案 # 内核瓶颈 减少网络小包的发送 将同一秒内推送的弹幕合并成一条，合并后每秒推送次数只等于在线连接数 锁瓶颈 大锁拆为多个小锁 创建原子变量，每个连接可以+1分配到一个唯一id，利用ID做hash取模到某个set中推送消息即遍历整个集合，顺序发送消息，耗时极长 连接打散到多个集合中，每个集合有自己的锁 多线程并发推送多个集合，避免锁的竞争 读写锁取代互斥锁，多个推送任务可以并发便利相同集合 cpu瓶颈 浏览器与服务器之间通常采用json格式通讯，json编码非常消耗cpu，每秒100w次json encode；因此减少计算次数 单机瓶颈 还有以下</description></item></channel></rss>