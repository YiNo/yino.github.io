<!doctype html><html lang=en dir=ltr><head><meta name=generator content="Hugo 0.97.3"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="并发&并行 #  Go应该是在内核级现成的基础上做了一层l逻辑上的虚拟线程（用户级线程）+ 线程调度系统 #   假如我们有一段CPU密集型任务 我们创建2000个goroutine 是否真的将性能提高2000倍，其实并不能； 我们只是进行2000并发（concurrenc） 而并没有真正做到并行（parallelism）。 并发是指我们的程序执行逻辑，传统单线程应用的程序逻辑是顺序执行的，在任何时刻，程序只能处理同一个逻辑，而并发是指，我们同时执行多个独立的程序逻辑，若干个程序逻辑在执行时可以是同时进行的（但不代表同时进行处理 其实还是一次处理一个）。实际上，不论我们并发多少个程序逻辑，若我们仅仅运行在一个单核单线程的CPU上，都不能让你的程序在性能上有所提升，因为最终所有任务都排队等待CPU资源（时间片）. 而并行才能让我们的程序真正的同时处理多个任务，但并行并不是编程语言能够带我们的特性，他需要硬件支持。上面说到单核CPU所有资源都要等待同一个CPU的资源，那么其实我们只要将CPU增多就能真正的让我们实现并行。我们可以使用多核CPU或用多台服务器组成服务集群，均可实现真正的并行，能够并行处理的任务数量也就是我们的CPU数量。
CPU密集&I/O密集 #   如果我们的程序是CPU密集型（计算型，深度学习等），使用并发编程，可能确实无法提升我们程序的性能，甚至有可能会下降，创建线程等也是会消耗资源的。 如果我们的程序是I/O密集型，当你在进行程序压测时CPU可能很低，但性能却到了瓶颈，原因时大部分时间都浪费在了等待I/O的过程中；如果我们在等待I/O的同时继续去执行其他的程序逻辑即可提高CPUl利用率，从而提高程序的性能，这就是并发编程的优点；例如Python因为GIL的存在实际上并不能实现真正的并行，但他的多线程依旧在IO密集型的程序中依旧有种很重要的意义；（遇到I/O操作 则切换线程；单线程+ 协程可能更优；减少了切换线程的开销）；
Goroutine（Golang Coroutine） #   使用多核CPU实现并行处理，使应用在多核cpu实现并行处理的方案主要是多进程与多线程两种方式，多进程模型相对简单，但是有着资源开销大及进程间通信成本高的问题。多线程模型相对复杂，会有死锁，线程安全，模型复杂等问题，但却因为资源开销及易于管理等优点适用于对于性能要求较高的应用。 Golang采用的是多线程模型，更详细的说他是一个两级线程模型，但它对系统线程（内核级线程）进行了封装，暴露了一个轻量级的协程goroutine（用户级线程）供用户使用，而用户级线程到内核级线程的调度由golang的runtime负责，调度逻辑对外透明。 goroutine的优势在于上下文切换在完全用户态进行，无需像线程一样频繁在用户态与内核态之间切换，节约了资源消耗。
G·P·M #  G（Goroutine） ：我们所说的协程，为用户级的轻量级线程，每个Goroutine对象中的sched保存着其上下文信息
M（Machine） ：对内核级线程的封装，数量对应真实的CPU数（真正干活的对象）、系统的
P（Processor） ：即为G和M的调度对象，用来调度G和M之间的关联关系，其数量可通过GOMAXPROCS()来设置，默认为核心数 他代表了真正的并发度，即有多少个goroutine可以同时运行"><meta name=theme-color content="#FFFFFF"><meta property="og:title" content><meta property="og:description" content="并发&并行 #  Go应该是在内核级现成的基础上做了一层l逻辑上的虚拟线程（用户级线程）+ 线程调度系统 #   假如我们有一段CPU密集型任务 我们创建2000个goroutine 是否真的将性能提高2000倍，其实并不能； 我们只是进行2000并发（concurrenc） 而并没有真正做到并行（parallelism）。 并发是指我们的程序执行逻辑，传统单线程应用的程序逻辑是顺序执行的，在任何时刻，程序只能处理同一个逻辑，而并发是指，我们同时执行多个独立的程序逻辑，若干个程序逻辑在执行时可以是同时进行的（但不代表同时进行处理 其实还是一次处理一个）。实际上，不论我们并发多少个程序逻辑，若我们仅仅运行在一个单核单线程的CPU上，都不能让你的程序在性能上有所提升，因为最终所有任务都排队等待CPU资源（时间片）. 而并行才能让我们的程序真正的同时处理多个任务，但并行并不是编程语言能够带我们的特性，他需要硬件支持。上面说到单核CPU所有资源都要等待同一个CPU的资源，那么其实我们只要将CPU增多就能真正的让我们实现并行。我们可以使用多核CPU或用多台服务器组成服务集群，均可实现真正的并行，能够并行处理的任务数量也就是我们的CPU数量。
CPU密集&I/O密集 #   如果我们的程序是CPU密集型（计算型，深度学习等），使用并发编程，可能确实无法提升我们程序的性能，甚至有可能会下降，创建线程等也是会消耗资源的。 如果我们的程序是I/O密集型，当你在进行程序压测时CPU可能很低，但性能却到了瓶颈，原因时大部分时间都浪费在了等待I/O的过程中；如果我们在等待I/O的同时继续去执行其他的程序逻辑即可提高CPUl利用率，从而提高程序的性能，这就是并发编程的优点；例如Python因为GIL的存在实际上并不能实现真正的并行，但他的多线程依旧在IO密集型的程序中依旧有种很重要的意义；（遇到I/O操作 则切换线程；单线程+ 协程可能更优；减少了切换线程的开销）；
Goroutine（Golang Coroutine） #   使用多核CPU实现并行处理，使应用在多核cpu实现并行处理的方案主要是多进程与多线程两种方式，多进程模型相对简单，但是有着资源开销大及进程间通信成本高的问题。多线程模型相对复杂，会有死锁，线程安全，模型复杂等问题，但却因为资源开销及易于管理等优点适用于对于性能要求较高的应用。 Golang采用的是多线程模型，更详细的说他是一个两级线程模型，但它对系统线程（内核级线程）进行了封装，暴露了一个轻量级的协程goroutine（用户级线程）供用户使用，而用户级线程到内核级线程的调度由golang的runtime负责，调度逻辑对外透明。 goroutine的优势在于上下文切换在完全用户态进行，无需像线程一样频繁在用户态与内核态之间切换，节约了资源消耗。
G·P·M #  G（Goroutine） ：我们所说的协程，为用户级的轻量级线程，每个Goroutine对象中的sched保存着其上下文信息
M（Machine） ：对内核级线程的封装，数量对应真实的CPU数（真正干活的对象）、系统的
P（Processor） ：即为G和M的调度对象，用来调度G和M之间的关联关系，其数量可通过GOMAXPROCS()来设置，默认为核心数 他代表了真正的并发度，即有多少个goroutine可以同时运行"><meta property="og:type" content="article"><meta property="og:url" content="https://kangkang17.cn/wiki/go/Go%E5%B9%B6%E5%8F%91%E5%8E%9F%E7%90%86%E5%8F%8AGPM%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5/"><meta property="article:section" content="wiki"><title>Go并发原理及 Gpm调度策略 | sun17 wiki</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.1639cc58b39d753e5ce211e45ca1950799431f352ff7bd1baadfa7fcedfe8043.css integrity="sha256-FjnMWLOddT5c4hHkXKGVB5lDHzUv970bqt+n/O3+gEM="><script defer src=/en.search.min.89d533e25029ff794547e1e5689ebd915a0fdcd3e980c169b7f1b2cd72c7ac70.js integrity="sha256-idUz4lAp/3lFR+HlaJ69kVoP3NPpgMFpt/GyzXLHrHA="></script>
<script defer src=/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js integrity="sha256-b2+Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC+NdcPIvZhzk="></script>
<link rel=apple-touch-icon sizes=128x128 href=128x128.jpg><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?65e05e8c0631a0d2802629f8ceb31fee",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e),console.log("欢迎加入，https://airdb.dev"),console.log("Welcome，https://airdb.dev")})()</script><nav class="app-nav pc no-badge"><div class=logo><a href=//airdb.dev/ target=__blank class=dcloud-logo></a>
<a href=./ class="uniapp-logo active"></a></div><div class="search nav-search"><div class=input-wrap><input type=search id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class=clear-button><svg width="26" height="24"><circle cx="12" cy="12" r="11" fill="#ccc"/><path stroke="#fff" stroke-width="2" d="M8.25 8.25l7.5 7.5"/><path stroke="#fff" stroke-width="2" d="M8.25 15.75l7.5-7.5"/></svg></div></div><div class=results-panel></div></div><ul class=nav-url></ul><ul class=nav-href><li class=ext-link><a href=https://github.com/airdb-wiki/hugo-book/discussions target=__blank>讨论区</a></li><li><a href=//github.com/sponsors/airdb target=__blank style=color:#f60!important><img src=https://bjetxgzv.cdn.bspapp.com/VKCEYUGU-uni-app-doc/45e691f0-4f3d-11eb-b680-7980c8a877b8.png class=heart>赞助我们</a></li></ul><div class=github><a href=//github.com/airdb-wiki/hugo-book target=_blank><img src=https://bjetxgzv.cdn.bspapp.com/VKCEYUGU-uni-app-doc/44f8d690-4f3d-11eb-b680-7980c8a877b8.svg></a></div></nav></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><ul><li><input type=checkbox id=section-a09650ef8147399d3ed4472880582323 class=toggle checked>
<label for=section-a09650ef8147399d3ed4472880582323 class="flex justify-between"><a>Golang</a></label><ul><li><a href=https://kangkang17.cn/wiki/go/go-laravel/>Go Laravel</a></li><li><a href=https://kangkang17.cn/wiki/go/Go%E5%B9%B6%E5%8F%91%E5%8E%9F%E7%90%86%E5%8F%8AGPM%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5/ class=active>Go并发原理及 Gpm调度策略</a></li><li><a href=https://kangkang17.cn/wiki/go/one_way/>One Way</a></li><li><a href=https://kangkang17.cn/wiki/go/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/>垃圾回收</a></li><li><a href=https://kangkang17.cn/wiki/go/%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E5%BA%93/>常用函数库</a></li><li><a href=https://kangkang17.cn/wiki/go/%E7%99%BE%E4%B8%87%E8%81%8A%E5%A4%A9%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/>百万聊天系统架构</a></li></ul></li><li><input type=checkbox id=section-5d225dd277df9f389326e86c5a85de5e class=toggle>
<label for=section-5d225dd277df9f389326e86c5a85de5e class="flex justify-between"><a>PHP</a></label><ul><li><a href=https://kangkang17.cn/wiki/PHP/fpm%E4%BC%98%E5%8C%96/>Fpm优化</a></li><li><a href=https://kangkang17.cn/wiki/PHP/function/excel-export/>Excel Export</a></li><li><a href=https://kangkang17.cn/wiki/PHP/function/%E5%AF%B9%E8%B1%A1%E4%B8%8E%E6%95%B0%E7%BB%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/>对象与数组相互转换</a></li><li><a href=https://kangkang17.cn/wiki/PHP/function/%E5%B8%B8%E7%94%A8header/>常用header</a></li></ul></li><li><input type=checkbox id=section-a8092a90142120f541d0346a9fe1efe8 class=toggle>
<label for=section-a8092a90142120f541d0346a9fe1efe8 class="flex justify-between"><a>Python</a></label><ul><li><a href=https://kangkang17.cn/wiki/Python/common-function/>Common Function</a></li><li><a href=https://kangkang17.cn/wiki/Python/queue/>Queue</a></li><li><a href=https://kangkang17.cn/wiki/Python/selenium/>Selenium</a></li><li><a href=https://kangkang17.cn/wiki/Python/tf-idf/>Tf IDF</a></li><li><a href=https://kangkang17.cn/wiki/Python/threading/>Threading</a></li><li><a href=https://kangkang17.cn/wiki/Python/uswgi%E4%B8%8Enginx/>Uswgi与nginx</a></li><li><a href=https://kangkang17.cn/wiki/Python/%E6%95%B0%E6%8D%AE%E9%9B%86/>数据集</a></li></ul></li><li><input type=checkbox id=section-6e6a8835e036b143f2b10bfed21ac4e1 class=toggle>
<label for=section-6e6a8835e036b143f2b10bfed21ac4e1 class="flex justify-between"><a>VUE</a></label><ul><li><a href=https://kangkang17.cn/wiki/VUE/iView%E6%A1%88%E4%BE%8B/>I View案例</a></li></ul></li><li><input type=checkbox id=section-2d090f3862b2af6eacac308f759f804b class=toggle>
<label for=section-2d090f3862b2af6eacac308f759f804b class="flex justify-between"><a>MySql</a></label><ul><li><a href=https://kangkang17.cn/wiki/MySql/mysql%E5%BC%82%E6%AD%A5%E5%A4%8D%E5%88%B6/>Mysql异步复制</a></li><li><a href=https://kangkang17.cn/wiki/MySql/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/>事务隔离级别</a></li><li><a href=https://kangkang17.cn/wiki/MySql/%E5%88%9B%E5%BB%BA%E5%87%BD%E6%95%B0/>创建函数</a></li><li><a href=https://kangkang17.cn/wiki/MySql/%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%E5%B9%B6%E6%8E%88%E6%9D%83/>创建用户并授权</a></li><li><a href=https://kangkang17.cn/wiki/MySql/%E5%B8%B8%E8%A7%81%E5%87%BD%E6%95%B0/>常见函数</a></li><li><a href=https://kangkang17.cn/wiki/MySql/%E5%BF%98%E8%AE%B0%E5%AF%86%E7%A0%81/>忘记密码</a></li></ul></li><li><input type=checkbox id=section-a65a3683145d96e127614a431001673a class=toggle>
<label for=section-a65a3683145d96e127614a431001673a class="flex justify-between"><a>Redis</a></label><ul><li><a href=https://kangkang17.cn/wiki/Redis/%E5%BC%82%E6%AD%A5%E5%A4%8D%E5%88%B6/>异步复制</a></li></ul></li><li><input type=checkbox id=section-ddacc913583033082c66dda009d6e95b class=toggle>
<label for=section-ddacc913583033082c66dda009d6e95b class="flex justify-between"><a>Mango</a></label><ul></ul></li><li><input type=checkbox id=section-bc6aae6425e70f60b3df6639bc25445c class=toggle>
<label for=section-bc6aae6425e70f60b3df6639bc25445c class="flex justify-between"><a>Docker</a></label><ul><li><a href=https://kangkang17.cn/wiki/Docker/Dockerfile/>Dockerfile</a></li><li><a href=https://kangkang17.cn/wiki/Docker/nginx-php-mysql%E4%B8%80%E4%BB%B6%E9%83%A8%E7%BD%B2/>Nginx Php Mysql一件部署</a></li><li><a href=https://kangkang17.cn/wiki/Docker/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/>常用命令</a></li></ul></li><li><input type=checkbox id=section-a176d5b766c2baa0491680256887e2da class=toggle>
<label for=section-a176d5b766c2baa0491680256887e2da class="flex justify-between"><a>Nginx</a></label><ul><li><a href=https://kangkang17.cn/wiki/Nginx/rewrite%E4%B8%8Eproxy_pass/>Rewrite与proxy Pass</a></li><li><a href=https://kangkang17.cn/wiki/Nginx/%E7%A6%81%E7%BD%91%E6%AE%B5/>禁网段</a></li></ul></li><li><input type=checkbox id=section-8486738ebb1d1cb03149de5f7a32b760 class=toggle>
<label for=section-8486738ebb1d1cb03149de5f7a32b760 class="flex justify-between"><a>Linux</a></label><ul><li><a href=https://kangkang17.cn/wiki/Linux/CentOS%E6%90%AD%E5%BB%BAShadowsocks%E6%9C%8D%E5%8A%A1%E7%AB%AF/>Cent Os搭建 Shadowsocks服务端</a></li><li><a href=https://kangkang17.cn/wiki/Linux/%E5%88%86%E7%BB%84/>分组</a></li><li><a href=https://kangkang17.cn/wiki/Linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/>常用命令</a></li></ul></li><li><input type=checkbox id=section-a5dbac202c116ec0c16a4c8223cef556 class=toggle>
<label for=section-a5dbac202c116ec0c16a4c8223cef556 class="flex justify-between"><a>微服务</a></label><ul><li><a href=https://kangkang17.cn/wiki/%E5%BE%AE%E6%9C%8D%E5%8A%A1/consul/>Consul</a></li></ul></li><li><input type=checkbox id=section-e96015fe40042d2fa8e59fcbc2ad4ed8 class=toggle>
<label for=section-e96015fe40042d2fa8e59fcbc2ad4ed8 class="flex justify-between"><a>领域驱动设计</a></label><ul><li><a href=https://kangkang17.cn/wiki/DDD/domain/>Domain</a></li><li><a href=https://kangkang17.cn/wiki/DDD/PO-DO-VO-DTO/>Po Do Vo Dto</a></li><li><a href=https://kangkang17.cn/wiki/DDD/%E5%AE%9E%E8%B7%B5/>实践</a></li><li><a href=https://kangkang17.cn/wiki/DDD/%E6%AD%A5%E9%AA%A4/>步骤</a></li><li><a href=https://kangkang17.cn/wiki/DDD/%E7%A4%BA%E4%BE%8B/>示例</a></li><li><a href=https://kangkang17.cn/wiki/DDD/%E8%81%9A%E5%90%88/>聚合</a></li></ul></li><li><input type=checkbox id=section-b97ebfeedd0ac8d494e2b15184691221 class=toggle>
<label for=section-b97ebfeedd0ac8d494e2b15184691221 class="flex justify-between"><a>规划</a></label><ul><li><a href=https://kangkang17.cn/wiki/Target/program/>Program</a></li><li><a href=https://kangkang17.cn/wiki/Target/target/>Target</a></li></ul></li></ul><div class=contact-item><div class=contact-smg><div>扫码添加企业微信</div><img src=https://airdb.dev/hugo-book/qrcode.png width=90 height=90></div></div></nav><script>(function(){var e=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Go并发原理及 Gpm调度策略</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><ul><li><ul><li><a href=#并发并行><strong>并发&并行</strong></a></li><li><a href=#go应该是在内核级现成的基础上做了一层l逻辑上的虚拟线程用户级线程-线程调度系统>Go应该是在内核级现成的基础上做了一层l逻辑上的虚拟线程（用户级线程）+ 线程调度系统</a></li></ul></li></ul></li></ul></nav></aside></header><article class=markdown><h3 id=并发并行><strong>并发&并行</strong>
<a class=anchor href=#%e5%b9%b6%e5%8f%91%e5%b9%b6%e8%a1%8c>#</a></h3><h3 id=go应该是在内核级现成的基础上做了一层l逻辑上的虚拟线程用户级线程-线程调度系统>Go应该是在内核级现成的基础上做了一层l逻辑上的虚拟线程（用户级线程）+ 线程调度系统
<a class=anchor href=#go%e5%ba%94%e8%af%a5%e6%98%af%e5%9c%a8%e5%86%85%e6%a0%b8%e7%ba%a7%e7%8e%b0%e6%88%90%e7%9a%84%e5%9f%ba%e7%a1%80%e4%b8%8a%e5%81%9a%e4%ba%86%e4%b8%80%e5%b1%82l%e9%80%bb%e8%be%91%e4%b8%8a%e7%9a%84%e8%99%9a%e6%8b%9f%e7%ba%bf%e7%a8%8b%e7%94%a8%e6%88%b7%e7%ba%a7%e7%ba%bf%e7%a8%8b-%e7%ba%bf%e7%a8%8b%e8%b0%83%e5%ba%a6%e7%b3%bb%e7%bb%9f>#</a></h3><p>          假如我们有一段CPU密集型任务 我们创建2000个goroutine 是否真的将性能提高2000倍，其实并不能； 我们只是进行2000并发（concurrenc） 而并没有真正做到并行（parallelism）。
并发是指我们的程序执行逻辑，传统单线程应用的程序逻辑是顺序执行的，在任何时刻，程序只能处理同一个逻辑，而并发是指，我们同时执行多个独立的程序逻辑，若干个程序逻辑在执行时可以是同时进行的（但不代表同时进行处理 其实还是一次处理一个）。实际上，不论我们并发多少个程序逻辑，若我们仅仅运行在一个单核单线程的CPU上，都不能让你的程序在性能上有所提升，因为最终所有任务都排队等待CPU资源（时间片）.
而并行才能让我们的程序真正的同时处理多个任务，但并行并不是编程语言能够带我们的特性，他需要硬件支持。上面说到单核CPU所有资源都要等待同一个CPU的资源，那么其实我们只要将CPU增多就能真正的让我们实现并行。我们可以使用多核CPU或用多台服务器组成服务集群，均可实现真正的并行，能够并行处理的任务数量也就是我们的CPU数量。</p><h4 id=cpu密集io密集><strong>CPU密集&I/O密集</strong>
<a class=anchor href=#cpu%e5%af%86%e9%9b%86io%e5%af%86%e9%9b%86>#</a></h4><p>          如果我们的程序是CPU密集型（计算型，深度学习等），使用并发编程，可能确实无法提升我们程序的性能，甚至有可能会下降，创建线程等也是会消耗资源的。
如果我们的程序是I/O密集型，当你在进行程序压测时CPU可能很低，但性能却到了瓶颈，原因时大部分时间都浪费在了等待I/O的过程中；如果我们在等待I/O的同时继续去执行其他的程序逻辑即可提高CPUl利用率，从而提高程序的性能，这就是并发编程的优点；例如Python因为GIL的存在实际上并不能实现真正的并行，但他的多线程依旧在IO密集型的程序中依旧有种很重要的意义；（遇到I/O操作 则切换线程；单线程+ 协程可能更优；减少了切换线程的开销）；</p><h4 id=goroutinegolang-coroutine><strong>Goroutine（Golang Coroutine）</strong>
<a class=anchor href=#goroutinegolang-coroutine>#</a></h4><p>          使用多核CPU实现并行处理，使应用在多核cpu实现并行处理的方案主要是多进程与多线程两种方式，多进程模型相对简单，但是有着资源开销大及进程间通信成本高的问题。多线程模型相对复杂，会有死锁，线程安全，模型复杂等问题，但却因为资源开销及易于管理等优点适用于对于性能要求较高的应用。
Golang采用的是多线程模型，更详细的说他是一个两级线程模型，但它对系统线程（内核级线程）进行了封装，暴露了一个轻量级的协程goroutine（用户级线程）供用户使用，而用户级线程到内核级线程的调度由golang的runtime负责，调度逻辑对外透明。
goroutine的优势在于上下文切换在完全用户态进行，无需像线程一样频繁在用户态与内核态之间切换，节约了资源消耗。</p><h4 id=gpm><strong>G·P·M</strong>
<a class=anchor href=#gpm>#</a></h4><p>G（Goroutine） ：我们所说的协程，为用户级的轻量级线程，每个Goroutine对象中的sched保存着其上下文信息</p><p>M（Machine） ：对内核级线程的封装，数量对应真实的CPU数（真正干活的对象）、系统的</p><p>P（Processor） ：即为G和M的调度对象，用来调度G和M之间的关联关系，其数量可通过GOMAXPROCS()来设置，默认为核心数 他代表了真正的并发度，即有多少个goroutine可以同时运行</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/yino/yino.github.io/edit/main/exampleSite/content/wiki/go/Go%e5%b9%b6%e5%8f%91%e5%8e%9f%e7%90%86%e5%8f%8aGPM%e8%b0%83%e5%ba%a6%e7%ad%96%e7%95%a5.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></div></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><ul><li><ul><li><a href=#并发并行><strong>并发&并行</strong></a></li><li><a href=#go应该是在内核级现成的基础上做了一层l逻辑上的虚拟线程用户级线程-线程调度系统>Go应该是在内核级现成的基础上做了一层l逻辑上的虚拟线程（用户级线程）+ 线程调度系统</a></li></ul></li></ul></li></ul></nav></div></aside></main></body></html>