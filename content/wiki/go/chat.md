### **聊天系统架构 百万级 B/S**
场景：100w人同时在线
#### 技术选型
```text
B/S架构下 通常有两种方案：
1. 客户端主动向服务器拉取数据
2. 服务器主动向客户端发送数据
以上两种情况在B/S架构下通常对应着：http轮询 和 websocket
在线用户达到一定量级情况下，客户端主动拉取数据就会达到一定的瓶颈：对单表、api压力过大；
因此在用户量级略高的情况下建议采用 websocket
```
#### websocket单机架构
websocket 单机架构 代码案例地址:
[gitee](https://gitee.com/sun17ya/go-websocket)
[github](https://github.com/yino/go-websocket)
##### 技术难点 
1. 内核瓶颈
```text
推送量大：100W*10条/秒=1000W条/秒
内核瓶颈：linux内核发送TCP极限包频≈100w
```
2. 锁瓶颈
```text
需要维护一个100w人的流量在线集合，通常是一个字典结构
推送消息即遍历整个集合，顺序发送消息，耗时极长
推送期间，客户端一直在进行上下线，所以需要对 map上锁
```
3. cpu瓶颈
```text
浏览器与服务器之间通常采用json格式通讯
json编码非常消耗cpu
每秒100w次json encode
```
##### 解决方案
1. 内核瓶颈
```text
减少网络小包的发送 
将同一秒内推送的弹幕合并成一条，合并后每秒推送次数只等于在线连接数
```
2. 锁瓶颈
```text
大锁拆为多个小锁 创建原子变量，每个连接可以+1分配到一个唯一id，利用ID做hash取模到某个set中推送消息即遍历整个集合，顺序发送消息，耗时极长
连接打散到多个集合中，每个集合有自己的锁
多线程并发推送多个集合，避免锁的竞争
读写锁取代互斥锁，多个推送任务可以并发便利相同集合
```
3. cpu瓶颈
```text

浏览器与服务器之间通常采用json格式通讯，json编码非常消耗cpu，每秒100w次json encode；因此减少计算次数
```

单机瓶颈 还有以下
```text
维护海量长链接会花费不少内存
消息推送瞬时消耗大量CPU资源
消息推送瞬时带宽高达400～600M（4-6Gbits）,是主要瓶颈
```

![image](/assets/img/websocket单体架构.jpg)


#### websocket分布式架构

##### 网关集群
![image](/assets/img/websocket网关集群.jpg)

通过负载均衡将连接打散在不同的网关服务器上，网关服务器可横向扩展；

但是会引出一个新的问题：当服务器推送消息时如何知道指定的用户在哪个服务器上：
最简单的解决方案是：将消息广播到所有的网关服务器上，网关服务器自主去决策是否在当前服务器，并进行发送；因此需要一个**逻辑集群**

##### 逻辑集群
 基于HTTP/2 协议向gateway 集群分发消息；HTTP/2 支持连接复用，用作RPC性能更佳；

 基于HTTP/1 协议对外提供推送API；HTTP/1 更加普及，对业务更加友好；

![image](/assets/img/websocket分布式整体架构.jpg)

当然我们也可以将逻辑集群中的HTTP 更换为消息中间件，采用消息订阅的方式分发给gateway；
